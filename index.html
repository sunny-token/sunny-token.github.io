<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Blog之HelloWord!">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Blog之HelloWord!">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Blog之HelloWord!">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> Blog之HelloWord! </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Blog之HelloWord!</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/24/iOS中打印日志显示系统详细时间，类名，行号，函数名，线程，及打印值/" itemprop="url">
                  iOS中打印日志显示系统详细时间，类名，行号，函数名，线程，及打印值
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-08-24T17:05:20+08:00" content="2016-08-24">
              2016-08-24
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p>Q：如何打印当前的函数和行号？<br>A：我们可以在打印时使用一些预编译宏作为打印参数，来打印当前的函数和行号。如：<br>NSLog(@”%s:%d obj=%@”, <strong>func</strong>, <strong>LINE</strong>, obj);</p>
<p>其中<strong>func</strong>和<strong>LINE</strong>都是预编译的宏，编译时会分别替换为当前函数和当前行号。<br>下面是一些常用于打印日志的宏。<br>宏    说明<br><strong>func</strong>    打印当前函数或方法，c字符串<br><strong>LINE</strong>    打印当前行号，整数<br><strong>FILE</strong>    打印当前文件路径，c字符串<br><strong>PRETTY_FUNCTION</strong>    打印当前函数或方法（在C++中会包含参数类型），c字符串</p>
<p>Q：如何打印一个类名，消息名，当前堆栈信息？</p>
<p>A：你可以使用以下方法在运行时动态获取这些信息。<br>代码    说明<br>NSStringFromSelector(SEL)    获取selector的名字<br>NSStringFromSelector(_cmd)    获取当前方法名<br>NSStringFromClass([object class])    获取object的类名<br>NSThread callStackSymbols]    获取当前线程的栈，是一个NSArry，包含堆栈中所有函数名。</p>
<p>Q：如何将日志打印到一个文件</p>
<p>A：可以使用freopen函数重定向标准输出和标准出错文件。因为printf函数会向标准输出（stdout）打印，而NSLog函数会向标准出错（stderr）打印。重新定向标准输出（stdout）和标准出错（stderr）到一个文件将会使他们打印日志到一个文件中。</p>
<p>freopen(“/tmp/log.txt”, “a+”, stdout);<br>freopen(“/tmp/log.txt”, “a+”, stderr);</p>
<p>#define NSLog(FORMAT, …) {/</p>
<p>NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];/</p>
<p>[dateFormatter setDateStyle:NSDateFormatterMediumStyle];/</p>
<p>[dateFormatter setTimeStyle:NSDateFormatterShortStyle];/</p>
<p>[dateFormatter setDateFormat:@”HH:mm:ss:SSSSSS”]; /</p>
<p>NSString *str = [dateFormatter stringFromDate:[NSDate date]];/</p>
<p>[dateFormatter release];/</p>
<p>fprintf(stderr,”[–%s–]<em>[–%s–]</em>[–%s:%d–]/n”,[str UTF8String], [[NSString stringWithFormat:FORMAT, ##<strong>VA_ARGS</strong>] UTF8String],[[[NSString stringWithUTF8String:<strong>FILE</strong>] lastPathComponent] UTF8String], <strong>LINE</strong>);/</p>
<p>}</p>
<p>原文地址：<a href="http://www.cnblogs.com/ThankForYou/archive/2012/09/12/2681739.html" target="_blank" rel="external">http://www.cnblogs.com/ThankForYou/archive/2012/09/12/2681739.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/22/使用Xcode查找项目中的中文字符串/" itemprop="url">
                  使用Xcode查找项目中的中文字符串
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-08-22T16:44:14+08:00" content="2016-08-22">
              2016-08-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/查找中文字符串/" itemprop="url" rel="index">
                    <span itemprop="name">查找中文字符串</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>项目刚启动的时候 我们一般为了快速开发 会在使用字符串的时候直接选择硬编码到代码中 比如</p>
<blockquote>
<p>self.lblTime.text = @”1分钟前”;</p>
</blockquote>
<p>但是之后 如果有国际化的需求的话 我们又会改成这样</p>
<blockquote>
<p>self.lblTime.text = NSLocalizedString(@”one_min_ago”, @”1分钟前”);</p>
</blockquote>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/08/22/使用Xcode查找项目中的中文字符串/#more" rel="contents">
              Weiterlesen &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/22/利用弱引用在block中使用self/" itemprop="url">
                  利用弱引用在block中使用self
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-08-22T09:10:33+08:00" content="2016-08-22">
              2016-08-22
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p>在block 使用日益频繁的现在，我们经常会使用<code>__block</code>,<code>__weak</code>。<br>但是每次写</p>
<blockquote>
<p> <strong>weak typeof(self)weakself = self;
</strong>block NSInteger xx = 0;</p>
</blockquote>
<p>多麻烦！<br>这里推荐一个宏，你只需要</p>
<blockquote>
<p>@weakify (self);<br>@strongify (self);</p>
</blockquote>
<p>然后 block 里面可以直接使用 self 了！</p>
<p>就可以使用了，上代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">#ifndef    weakify</div><div class="line"> #if __has_feature(objc_arc)</div><div class="line"></div><div class="line"> #define weakify( x ) \</div><div class="line"> _Pragma(&quot;clang diagnostic push&quot;) \</div><div class="line"> _Pragma(&quot;clang diagnostic ignored \&quot;-Wshadow\&quot;&quot;) \</div><div class="line"> autoreleasepool&#123;&#125; __weak __typeof__(x) __weak_##x##__ = x; \</div><div class="line"> _Pragma(&quot;clang diagnostic pop&quot;)</div><div class="line"></div><div class="line"> #else</div><div class="line"></div><div class="line"> #define weakify( x ) \</div><div class="line"> _Pragma(&quot;clang diagnostic push&quot;) \</div><div class="line"> _Pragma(&quot;clang diagnostic ignored \&quot;-Wshadow\&quot;&quot;) \</div><div class="line"> autoreleasepool&#123;&#125; __block __typeof__(x) __block_##x##__ = x; \</div><div class="line"> _Pragma(&quot;clang diagnostic pop&quot;)</div><div class="line"></div><div class="line"> #endif</div><div class="line"> #endif</div><div class="line"></div><div class="line"> #ifndef    strongify</div><div class="line"> #if __has_feature(objc_arc)</div><div class="line"></div><div class="line"> #define strongify( x ) \</div><div class="line"> _Pragma(&quot;clang diagnostic push&quot;) \</div><div class="line"> _Pragma(&quot;clang diagnostic ignored \&quot;-Wshadow\&quot;&quot;) \</div><div class="line"> try&#123;&#125; @finally&#123;&#125; __typeof__(x) x = __weak_##x##__; \</div><div class="line"> _Pragma(&quot;clang diagnostic pop&quot;)</div><div class="line"></div><div class="line"> #else</div><div class="line"></div><div class="line"> #define strongify( x ) \</div><div class="line"> _Pragma(&quot;clang diagnostic push&quot;) \</div><div class="line"> _Pragma(&quot;clang diagnostic ignored \&quot;-Wshadow\&quot;&quot;) \</div><div class="line"> try&#123;&#125; @finally&#123;&#125; __typeof__(x) x = __block_##x##__; \</div><div class="line"> _Pragma(&quot;clang diagnostic pop&quot;)</div><div class="line"></div><div class="line"> #endif</div><div class="line"> #endif</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/18/webViewJavascriptBridge使用方法/" itemprop="url">
                  webViewJavascriptBridge使用方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-08-18T11:59:30+08:00" content="2016-08-18">
              2016-08-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/webViewJavascriptBridge/" itemprop="url" rel="index">
                    <span itemprop="name">webViewJavascriptBridge</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p>##首先有两个问题：<br>a.Native中的UIWebView是否可以直接调用js method（方法）？ <br><br>可以。只需要调用<code>[webview stringByEvaluatingJavaScriptFromString:@&quot;&quot;];</code>就可以了</p>
<p>b.js 是否可以直接调用Native的method？<br><br>不行。</p>
<p>所以，这里介绍一下<code>webViewJavascriptBridge</code>，这个封装的比较好的一个第三方库。</p>
<p>##原理分析：</p>
<p>js不能调用 Native的方法，所以，需要利用webView的重定向原理（即重新在js中指定document.location的值，此为一url），只要在这个url字符串中按自定义的规则指定好所需调用oc中的函数和参数，然后通过OC中的<code>shouldStartLoadWithRequest</code>函数去捕获处理请求，处理完最后，如果js还想获取一些返回参数的话，同样让oc去通过<code>stringByEvaluatingJavaScriptFromString</code>调用刚js传过来的回调js函数就行，顺道把参数也一起传了。</p>
<p>##使用步骤</p>
<ol>
<li>增加下面的代码到你的 Podfile，然后运行pod install 进行安装<br><code>pod &#39;WebViewJavascriptBridge&#39;, &#39;~&gt; 5.0&#39;</code></li>
<li>导入头文件，并增加属性<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#import &quot;WebViewJavascriptBridge.h&quot;</div><div class="line">...</div><div class="line">@property WebViewJavascriptBridge* bridge;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>3.实例化<code>WebViewJavascriptBridge</code>，并绑定到你的 webview 上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.bridge = [WebViewJavascriptBridge bridgeForWebView:webView];</div></pre></td></tr></table></figure></p>
<ol>
<li>与前端的 HTML 开发约定一下规则，在HTML 写 JS 的时候初始化一下下面的代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function setupWebViewJavascriptBridge(callback) &#123;</div><div class="line">    if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125;</div><div class="line">    if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125;</div><div class="line">    window.WVJBCallbacks = [callback];</div><div class="line">    var WVJBIframe = document.createElement(&apos;iframe&apos;);</div><div class="line">    WVJBIframe.style.display = &apos;none&apos;;</div><div class="line">    WVJBIframe.src = &apos;wvjbscheme://__BRIDGE_LOADED__&apos;;</div><div class="line">    document.documentElement.appendChild(WVJBIframe);</div><div class="line">    setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>5.最后，就可以相互调用了，只需要约定好相互的方法名，就可以很简单的调用了</p>
<p>这是在 JS 里面写的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">setupWebViewJavascriptBridge(function(bridge) &#123;</div><div class="line">    //注册 JS 的方法给原生调用，并且能有回调返回给原生</div><div class="line">    bridge.registerHandler(&apos;JS Echo&apos;, function(data, responseCallback) &#123;</div><div class="line">        console.log(&quot;JS Echo called with:&quot;, data)</div><div class="line">        responseCallback(data)</div><div class="line">    &#125;)</div><div class="line">    //调用原生的已经注册好的方法，能传值，也能接收返回值</div><div class="line">    bridge.callHandler(&apos;ObjC Echo&apos;, &#123;&apos;key&apos;:&apos;value&apos;&#125;, function responseCallback(responseData) &#123;</div><div class="line">        console.log(&quot;JS received response:&quot;, responseData)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>这是在原生界面写的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//注册原生界面的方法</div><div class="line">[self.bridge registerHandler:@&quot;ObjC Echo&quot; handler:^(id data, WVJBResponseCallback responseCallback) &#123;</div><div class="line">    NSLog(@&quot;ObjC Echo called with: %@&quot;, data);</div><div class="line">    responseCallback(data);</div><div class="line">&#125;];</div><div class="line">//调用 JS 注册好的方法</div><div class="line">[self.bridge callHandler:@&quot;JS Echo&quot; responseCallback:^(id responseData) &#123;</div><div class="line">    NSLog(@&quot;ObjC received response: %@&quot;, responseData);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/15/自动缩1倍图脚本/" itemprop="url">
                  自动缩1倍图脚本
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-08-15T15:06:02+08:00" content="2016-08-15">
              2016-08-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/自动-图片/" itemprop="url" rel="index">
                    <span itemprop="name">自动 图片</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p>##依赖环境<br>Ruby脚本，依赖于ImageMagick库</p>
<p>##安装ImageMagick<br>这步最麻烦因为这库安装就是麻烦，推荐使用homebrew安装，所以先安装homebrew，这是Mac上使用最广泛的一个包管理器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby -e &quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)&quot;</div></pre></td></tr></table></figure></p>
<p>然后安装ImageMagick<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install imagemagick</div></pre></td></tr></table></figure></p>
<p>##安装mini_magick<br>这是一个ruby gem<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install mini_magick</div></pre></td></tr></table></figure></p>
<p>如果安装太慢，可以考虑换一下gem源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gem sources -r https://rubygems.org/</div><div class="line">gem sources -a https://ruby.taobao.org/</div></pre></td></tr></table></figure></p>
<p>##脚本<br>脚本内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">require &apos;mini_magick&apos;</div><div class="line">dir = &apos;2倍&apos;</div><div class="line">Dir.glob(&quot;#&#123;dir&#125;/**/*.png&quot;).each do |f|</div><div class="line">    ext = File.extname(f)</div><div class="line">     </div><div class="line">    newFilename = &quot;#&#123;File.dirname(f)&#125;/#&#123;File.basename(f, ext)&#125;@2x#&#123;ext&#125;&quot;</div><div class="line">    File.rename(f, newFilename)</div><div class="line"> </div><div class="line">    puts newFilename</div><div class="line">    puts f</div><div class="line"> </div><div class="line">    image = MiniMagick::Image.open(newFilename)</div><div class="line">    ds = image.dimensions</div><div class="line">    image.resize &quot;#&#123;ds[0]/2&#125;x#&#123;ds[1]/2&#125;&quot;</div><div class="line">    image.write f</div><div class="line">end</div></pre></td></tr></table></figure></p>
<p>需要调整的是第二行的变量，指定目录的名字</p>
<p>调整完成后，将脚本保存为resize.rb，放到与指定目录平级的地方，然后执行 ruby resize.rb 即可</p>
<p>这个脚本会将当前目录下所有的png文件先全部重命名为@2x.png，然后生成1倍图，并使用原图的名字</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/10/MLeaksFinder：精准 iOS 内存泄露检测工具/" itemprop="url">
                  MLeaksFinder：精准 iOS 内存泄露检测工具
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-08-10T09:13:45+08:00" content="2016-08-10">
              2016-08-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/MLeaksFinder/" itemprop="url" rel="index">
                    <span itemprop="name">MLeaksFinder</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>##背景<br>平常我们都会用 Instrument 的 Leaks / Allocations 或其他一些开源库进行内存泄露的排查，但它们都存在各种问题和不便，我们逐个来看这些工具的使用和存在的问题。</p>
<p>##Leaks</p>
<p>先看看 Leaks，从苹果的开发者文档里可以看到，一个 app 的内存分三类：</p>
<blockquote>
<ol>
<li>Leaked memory: Memory unreferenced by your application that cannot<br>be used again or freed (also detectable by using the Leaks<br>instrument).</li>
<li>Abandoned memory: Memory still referenced by your application that<br>has no useful purpose.</li>
<li>Cached memory: Memory still referenced by your application that<br>might be used again for better performance.</li>
</ol>
</blockquote>
<p>其中 Leaked memory 和 Abandoned memory 都属于应该释放而没释放的内存，都是内存泄露，而 Leaks 工具只负责检测 Leaked memory，而不管 Abandoned memory。在 MRC 时代 Leaked memory 很常见，因为很容易忘了调用 release，但在 ARC 时代更常见的内存泄露是循环引用导致的 Abandoned memory，Leaks 工具查不出这类内存泄露，应用有限。<br>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/08/10/MLeaksFinder：精准 iOS 内存泄露检测工具/#more" rel="contents">
              Weiterlesen &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/04/block 和 delegate 在 property 中的属性设置/" itemprop="url">
                  block 和 delegate 在 property 中的属性设置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-08-04T16:36:48+08:00" content="2016-08-04">
              2016-08-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/block-delegate/" itemprop="url" rel="index">
                    <span itemprop="name">block delegate</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p>##block<br><code>block</code>在<code>property</code>中的属性应该是<code>strong</code>还是<code>copy</code>呢？<br><br>答案是:<code>copy</code>.<br></p>
<blockquote>
<p>因为当<code>block</code>存储在<code>property</code>,<code>NSArray</code>或者其他数据结构中的时候，<code>copy</code>和<code>strong</code>是有很大的区别的,简单来说,你应该使用<code>copy</code>.当<code>block</code>第一次被创建的时候,它是被创建在栈上的,如果你调用<code>block</code>的时候,它已经被释放了,那么你就会得到一个很严重的<br>bug &lt; EXC_BAD_ACCESS&gt;.<br><br>如果你用了<code>strong</code>(相当于<code>retain</code>)去创建<code>block</code>,其实它什么都没发生,它还是在栈上的.<br><br>如果你使用了<code>copy</code>属性去创建<code>block</code>,它将会被创建在堆上,那么你去使用的话,就不会出现 crash .<br>并且如果你要把<code>block</code>保存在<code>NSMutableArrays</code>中，请一定要使用<code>copy</code>而不是<code>strong</code>或<code>retain</code>.</p>
</blockquote>
<p>##delegate<br>@property (nonatomic, assign) id delegate;<br>@property (nonatomic, weak) id delegate;<br>哪个好呢？<br>答案:<code>weak</code>.<br>因为:一般来说,两者的作用是一致的.<br>但是经过测试,声明一个<code>delegate</code>之前一直使用的是<code>assign</code>，今天调试一段代码的时候，发现程序会<code>crash</code>掉，报错<code>EXC_BAD_ACCESS</code>.</p>
<blockquote>
<p>@property (nonatomic, assign) id delegate;<br>声明一个delegate，那么即便delegate指向的对象销毁了，delegate中依然会保存之前对象的地址<br>即，delegate成为了一个野指针…<br>@property (nonatomic, weak) id delegate;<br>而使用weak，则不会有上述问题，当delegate指向的对象销毁后，delegate = nil，<br>所以答案就是，使用weak。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/03/iOS开发：后台运行以及保持程序在后台长时间运行/" itemprop="url">
                  iOS开发：后台运行以及保持程序在后台长时间运行
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-08-03T13:14:08+08:00" content="2016-08-03">
              2016-08-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/后台/" itemprop="url" rel="index">
                    <span itemprop="name">后台</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p>##第一部分</p>
<p>1.先说说iOS 应用程序5个状态：</p>
<p>停止运行-应用程序已经终止，或者还未启动。</p>
<p>不活动-应用程序处于前台但不再接收事件（例如，用户在app处于活动时锁住了设备）。</p>
<p>活动-app处于“使用中”的状态。</p>
<p>后台-app不再屏幕上显示，但它仍然执行代码。</p>
<p>挂起-app仍然驻留内存但不再执行代码。</p>
<p>按下Home键时，app从活动状态转入后台，绝大部分app通常在几秒内就从后台变成了挂起。</p>
<p>在内存吃紧的时候，iphone会首先关闭那些挂起的app。</p>
<p>从 iOS 4 开始，应用就可以在退到后台后，继续运行一小段时间（10 分钟）；</p>
<p>2.还可以把自己声明为需要在后台运行，就能不限时地运行了。</p>
<p>不过限制为播放音乐、使用 GPS 、voip、。 值得一提的是，有的应用为了达到后台不限时运行的目的，在后台播放无声的音乐（审核不一定会被发现）。</p>
<p>iOS 5 开始又多了一种类型：下载报刊杂志。</p>
<p>然后 iOS 7 则可以下载各种玩意和定时抓取。</p>
<p>iOS 7 需要注意的区别：iOS 7 以前，应用进入后台继续运行时，如果用户锁屏了，那么 iOS 会等待应用运行完，才进入睡眠状态。而在 iOS 7 上，系统会很快进入睡眠状态，那些后台应用也就暂停了。如果收到事件被唤醒（例如定时事件、推送、位置更新等），后台应用才能继续运行一会。因为处理过程变成了断断续续的，因此下载时也要使用 NSURLSession 来处理（即下文中的 Background Transfer Service）。</p>
<ol>
<li>在我看来，苹果限制 app在后台运行，是为了更有效的利用硬件使用当前的app，不然，过多的app驻留后台，对手机资源占用是一大问题。</li>
</ol>
<p>二. ios7以后提供的后台接口模式</p>
<p>1、Background Audio，这是后台的音频，这个很早之前便有，也是iOS设备中用得最多的后台应用，调用这个接口可以实现后台的音乐播放。</p>
<p>2、Location Services，这是后台的定位，系统会拥有统一页面进行管理。</p>
<p>3、VoIP，后台语音服务，类似Skype通话应用需要调用，可进行后台的语音通话。</p>
<p>4、Newsstand，报刊杂志后台自动下载更新，其能够自动实时更新。</p>
<p>5、Background Task  Completion，这个接口早在iOS4时候便拥有，其可以供任意类型的APP使用，不过在旧系统中，这个接口的后台限制运行时间仅为10分钟，意味着当应用退至后台，其后台运行仅能持续10分钟便会转至休眠状态。iOS 7中对这个接口作出了改变，原来的为连续10分钟，即不论你这10分钟内用户是否关闭屏幕进入休眠状态，应用仍然会在后台等待10分钟完结后推出，而新的改进为假如遇到关闭屏幕休眠的情况，这后台运行的10分钟便会跟随一同休眠，剩余的后台时间将会留待用户再一次唤醒设备才计算。这样后台运行的时间仍然为10分钟，但并不连续，这样做的优点为省电。</p>
<p>如现在有一些词典应用带有后台复制选词功能，实际上其是利用了这个接口，如果用户开启词典后并推出，即使屏幕关闭，但词典仍然在后台运行，电量消耗还是比较大的，在iOS 7上，这个问题可以得到解决。</p>
<p>6、 Remote Notification，这是本次较大的一个改进接口，以往聊天类应用接受推送后点进去需要再收一次信息，这情况在QQ、微信等应用上最为明显。不过拥有了这个接口后，这情况将不复存在，以后推送将能够直接启动后台任务。值得注意的是remote notification支持silent notification（静默推送），这样dropbox这类同步应用可以在后台以最节能的模式实时静默同步了，类似布卡漫画这种也可以推送正在追的漫画的新章节并在后台静默下载，待到下载好再给用户发送一个本地推送，用户点开即看无需再联网。</p>
<p>7、Background Transfer Service，后台上传下载。iOS最接近传统多任务的后台接口，可供任意类型的app调用，无时间限制。应用场景包括后台上传和下载数据，这使得游戏后台更新数据包，后台上传视频等等都成为可能，但是正如其名字，它只能用于处理上传下载这种传输类的任务，类似后台剪切板监控这种它就无能为力了。</p>
<p>iOS 7新增的background fetch，这个后台接口在苹果WWDC 2013上有提及，其会根据用户行为自动调整达到效率最优的后台模式，能够处理不是很有时效性的信息获取。例如一些社交、新闻类的应用的后台信息更新，iOS系统便会根据应用启动频率、时间和当前网络和电量的状况来智能分配每个应用的后台获取频率和启动时长。</p>
<p>三 .  当前社交项目，如何使用ios后台</p>
<p>1.当前项目特点：</p>
<p>a. 在保存长连接的情况下，用户一直在线，才能即时接收到消息；</p>
<p>b. 在初始化连接的时候，需要做很多处理，如果经常连接，必然很耗电， 所以尽力在后台的时候，不是时常断开后又连接；</p>
<ol>
<li>通过以上分析，改选用何种方式来保存app后台运行</li>
</ol>
<p>voip不行；</p>
<p>静音播放，不清楚这种方式，是否可以通过审核；</p>
<p>vpns推送，可取的方式，（具体方法： 用户在登录后，发送一个设备的tokenid； 在发送消息时，平台根据对方是离线还是在线，来判断要不要发推送消息）</p>
<p>3.background fetch在该项目中的应用</p>
<p>由于该app在初始化时，需要耗点时间，最好的方式就是通过  后台获取  来处理该工作，这样能保证用户的流畅体验。</p>
<p>##第二部分：保持程序在后台长时间运行</p>
<p>iOS为了让设备尽量省电，减少不必要的开销，保持系统流畅，因而对后台机制采用墓碑式的“假后台”。除了系统官方极少数程序可以真后台，一般开发者开发出来的应用程序后台受到以下限制：</p>
<blockquote>
<p>1.用户按Home之后，App转入后台进行运行，此时拥有180s后台时间（iOS7）或者600s（iOS6）运行时间可以处理后台操作<br>2.当180S或者600S时间过去之后，可以告知系统未完成任务，需要申请继续完成，系统批准申请之后，可以继续运行，但总时间不会超过10分钟。<br>3.当10分钟时间到之后，无论怎么向系统申请继续后台，系统会强制挂起App，挂起所有后台操作、线程，直到用户再次点击App之后才会继续运行。</p>
</blockquote>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic,unsafe_unretained)UIBackgroundTaskIdentifier backgroundTaskIdentifier;</div><div class="line">- (void)applicationDidEnterBackground:(UIApplication *)application &#123;   </div><div class="line">    [self timerMethod:nil];</div><div class="line">    self.backgroundTaskIdentifier = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^(void)&#123;</div><div class="line">        [self endBackgroundTask];</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later.</div><div class="line">    // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)timerMethod:(NSTimer *)paramSender &#123;</div><div class="line">    NSTimeInterval backgroundTimeRemaining = [[UIApplication sharedApplication] backgroundTimeRemaining];</div><div class="line">    if (backgroundTimeRemaining == DBL_MAX)&#123;</div><div class="line">        NSLog(@&quot;Background Time Remaining = Undetermined&quot;);</div><div class="line">    &#125; else &#123;</div><div class="line">        //        [self performSelectorInBackground:@selector(updateFmdb) withObject:nil];</div><div class="line">        NSLog(@&quot;Background Time Remaining = %.02f Seconds&quot;, backgroundTimeRemaining);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)endBackgroundTask &#123;</div><div class="line">    dispatch_queue_t mainQueue = dispatch_get_main_queue();</div><div class="line">    __weak AppDelegate *weakSelf = self;</div><div class="line">    dispatch_async(mainQueue, ^(void) &#123;</div><div class="line">        AppDelegate *strongSelf = weakSelf;</div><div class="line">        if (strongSelf != nil)&#123;</div><div class="line">            [[UIApplication sharedApplication] endBackgroundTask:self.backgroundTaskIdentifier];</div><div class="line">            strongSelf.backgroundTaskIdentifier = UIBackgroundTaskInvalid;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然iOS为了特殊应用也保留了一些可以实现“真后台”的方法，摘取比较常用的：</p>
<p>1.VOIP</p>
<p>2.定位服务</p>
<p>3.后台下载</p>
<p>4.在后台一直播放无声音乐（容易受到电话或者其他程序影响，所以暂未考虑）<br>步骤：<br>a.在plish文件中加入背景播放的支持。<br>加入项：Required background modes。并设置为：audio<br>b.初始化一个AVAudioPlayer音频，并且无限制的播放下去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    [super viewDidLoad];</div><div class="line"></div><div class="line">   </div><div class="line"></div><div class="line">    dispatch_queue_t dispatchQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line"></div><div class="line">  dispatch_async(dispatchQueue, ^(void) &#123;</div><div class="line"></div><div class="line">    NSError *audioSessionError = nil;</div><div class="line"></div><div class="line">    AVAudioSession *audioSession = [AVAudioSession sharedInstance];</div><div class="line"></div><div class="line">    if ([audioSession setCategory:AVAudioSessionCategoryPlayback error:&amp;audioSessionError])&#123;</div><div class="line"></div><div class="line">            NSLog(@&quot;Successfully set the audio session.&quot;);</div><div class="line"></div><div class="line">    &#125; else &#123;</div><div class="line"></div><div class="line">            NSLog(@&quot;Could not set the audio session&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">     </div><div class="line"></div><div class="line">     </div><div class="line"></div><div class="line">    NSBundle *mainBundle = [NSBundle mainBundle];</div><div class="line"></div><div class="line">    NSString *filePath = [mainBundle pathForResource:@&quot;mySong&quot; ofType:@&quot;mp3&quot;];</div><div class="line"></div><div class="line">    NSData *fileData = [NSData dataWithContentsOfFile:filePath];</div><div class="line"></div><div class="line">    NSError *error = nil;</div><div class="line"></div><div class="line">    </div><div class="line"></div><div class="line">    self.audioPlayer = [[AVAudioPlayer alloc] initWithData:fileData error:&amp;error];</div><div class="line"></div><div class="line">     </div><div class="line"></div><div class="line">    if (self.audioPlayer != nil)&#123;</div><div class="line"></div><div class="line">      self.audioPlayer.delegate = self;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">      [self.audioPlayer setNumberOfLoops:-1];</div><div class="line"></div><div class="line">       if ([self.audioPlayer prepareToPlay] &amp;&amp; [self.audioPlayer play])&#123;</div><div class="line"></div><div class="line">                 NSLog(@&quot;Successfully started playing...&quot;);</div><div class="line"></div><div class="line">       &#125; else &#123;</div><div class="line"></div><div class="line">         NSLog(@&quot;Failed to play.&quot;);</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">     &#125; else &#123;</div><div class="line"></div><div class="line">            </div><div class="line"></div><div class="line">     &#125;</div><div class="line"></div><div class="line">  &#125;);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5.更多<br>其中VOIP需要绑定一个Socket链接并申明给系统，系统将会在后台接管这个连接，一旦远端数据过来，你的App将会被唤醒10s（或者更少）的时间来处理数据，超过时间或者处理完毕，程序继续休眠。</p>
<p>后台现在是iOS7引入的新API，网上实现的代码比较少，博主也没有细心去找。</p>
<p>由于博主要做的App需要在后台一直运行，每隔一段时间给服务器主动发送消息来保持帐号登陆状态，因而必须确保App不被系统墓碑限制。</p>
<p>博主最先尝试了很多方法，包括朋友发来的一个Demo，每180s后台时间过期就销毁自己然后再创建一个后台任务，但是实际测试只有10分钟时间。最后因为考虑到VOIP对服务端改动太大，时间又太紧，所以选择了定位服务的方法来保持后台。</p>
<p>要启动定位服务：</p>
<p>a.需要引入头文件：<code>#import</code></p>
<p>b.在<code>AppDelegate.m</code>中定义<code>CLLocationManager * locationManager;</code>作为全局变量方便控制</p>
<p>c.在程序启动初期对定位服务进行初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">locationManager = [[CLLocationManager alloc] init];</div><div class="line"></div><div class="line">locationManager.delegate =self;//or whatever class you have for managing location</div></pre></td></tr></table></figure></p>
<p>d.在程序转入后台的时候，启动定位服务</p>
<blockquote>
<p>[locationManager startUpdatingLocation];(第一次运行这个方法的时候，如果之前用户没有使用过App，则会弹出是否允许位置服务，关于用户是否允许，后面代码中有判断）</p>
</blockquote>
<p>这样在定位服务可用的时候，程序会不断刷新后台时间，实际测试，发现后台180s时间不断被刷新，达到长久后台的目的。</p>
<p>但是这样使用也有一些问题，在部分机器上面，定位服务即使打开也可能不能刷新后台时间，需要完全结束程序再运行。稳定性不知道是因为代码原因还是系统某些机制原因。</p>
<p><br><br>6.企业部署</p>
<p>你可以将任何app声明为上述5种类型以获得无限的后台运行时间，但当你提交app到App Store时，苹果会审查你的app，一旦发现你“滥用”了后台API，你的app将被拒绝。<br>当然，对于企业开发而言，不存在“滥用”的问题——企业app可以通过OTA部署，不经过苹果商店审查。<br>在企业部署中，你可以将一个app声明为VoIP，但这个程序根本和VoIP无关，我们的目的只是为了让iOS给我们无限后台执行的权限。声明过程是在app的Info.plist文件中加入以下key：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;key&gt;UIBackgroundModes&lt;/key&gt;</div><div class="line">&lt;array&gt;</div><div class="line">&lt;string&gt;voip&lt;/string&gt;</div><div class="line">&lt;/array&gt;</div></pre></td></tr></table></figure></p>
<p>我测试了以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">- (void)backgroundHandler &#123;</div><div class="line">    NSLog(@&quot;### --&gt;backgroundinghandler&quot;);</div><div class="line">    UIApplication*    app = [UIApplicationsharedApplication];</div><div class="line">    bgTask = [app beginBackgroundTaskWithExpirationHandler:^&#123;</div><div class="line">       [app endBackgroundTask:bgTask];</div><div class="line">        bgTask = UIBackgroundTaskInvalid;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    // Start the long-running task</div><div class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">        while (1) &#123;</div><div class="line">            NSLog(@&quot;counter:%ld&quot;, counter++);</div><div class="line">            sleep(1);</div><div class="line">       &#125;  </div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)applicationDidEnterBackground:(UIApplication *)application</div><div class="line"></div><div class="line">&#123;</div><div class="line">    BOOL backgroundAccepted = [[UIApplicationsharedApplication] setKeepAliveTimeout:600 handler:^&#123; [selfbackgroundHandler]; &#125;];</div><div class="line"></div><div class="line">    if (backgroundAccepted)</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        NSLog(@&quot;backgrounding accepted&quot;);</div><div class="line">    &#125;</div><div class="line">    [selfbackgroundHandler];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过测试，我获得了“无限的”后台执行时间。我不知道你认为“无限”到底是多长时间，但在这个例子中，后台任务至少运行了55个小时以上，一直到我失去耐心停止测试。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/03/xcode 插件组 Alcatraz 的安装方法/" itemprop="url">
                  xcode 插件组 Alcatraz 的安装方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-08-03T08:44:16+08:00" content="2016-08-03">
              2016-08-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Alcatraz/" itemprop="url" rel="index">
                    <span itemprop="name">Alcatraz</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p>#<a href="https://github.com/alcatraz/Alcatraz" target="_blank" rel="external">Alcatraz</a><br><code>Alcatraz</code>是一个为 <code>xcode7+</code> 管理开源代码的工具，可以为 <code>xcode</code> 自动查找安装插件，模板和主题颜色，不需要手动拷贝文件。</p>
<p>##安装<br>打开 <code>Terminal</code> 复制以下链接：</p>
<blockquote>
<p>curl -fsSL <a href="https://raw.github.com/alcatraz/Alcatraz/master/Scripts/install.sh" target="_blank" rel="external">https://raw.github.com/alcatraz/Alcatraz/master/Scripts/install.sh</a> | sh</p>
</blockquote>
<p>或者可以手动下载 zip 包然后在 xcode 中编译，<code>Alcatraz</code> 需要在 <code>Preferences &gt; Downloads</code> 中安装 <code>Xcode Command Line Tools</code>.</p>
<p>##使用<br>从 <code>window</code> 窗口选择 <code>Package Manager</code> ，你就可以安装或卸载你所需要的插件。安装好的插件会在每次 <code>Alcatraz</code> 启动后检查更新.<br><img src="https://camo.githubusercontent.com/70505dece9a75af5ca4715fff66271127f7d5b78/687474703a2f2f616c63617472617a2e696f2f696d616765732f6d656e754032782e706e67" alt="此处输入图片的描述"></p>
<p>##卸载<br>打开 <code>Terminal</code> 复制以下链接：</p>
<blockquote>
<p>rm -rf ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin</p>
</blockquote>
<p>如果需要删除全部 <code>Alcatraz</code> 插件:</p>
<blockquote>
<p>rm -rf ~/Library/Application\ Support/Alcatraz/</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/29/protobuf的初级使用/" itemprop="url">
                  protobuf的初级使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-07-29T15:29:03+08:00" content="2016-07-29">
              2016-07-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/protobuf/" itemprop="url" rel="index">
                    <span itemprop="name">protobuf</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<p>转载:<a href="http://m.blog.csdn.net/article/details?id=44244687" target="_blank" rel="external">iOS中从零开始使用protobuf</a></p>
<p>让我们一起打开下面这个链接<br><a href="https://github.com/alexeyxo/protobuf-objc" target="_blank" rel="external">https://github.com/alexeyxo/protobuf-objc</a></p>
<p>在github上有protobuf-objc，其中的readme可以教会我们安装proto到咱们电脑里面。然后利用protoc，也就是protobuf的编译器可以编译.proto文件，生成一些.h和.m文件。<br>在移动App中，使用protobuffer可以做储存，可以做网络传输，可以干很多和数据打交道的事情。<br>最简单的，加入做一个APP，你要记录用户数据对吧？用户账号是？密码是？性别是？有没有女朋友？<br>为了记录这些数据到服务器，就需要合适的数据结构。有人说，为什么一定要用protobuf？为什么不用其他的如json？如xml？关于这个问题，请到stackoverflow，csdn等格调甚高的地方去寻找，去发现。。我要用的原因，就是我需要用，不用就会落后，就会挨打。。</p>
<p>首先是怎么安装protobuf这个工程。<br>(摘抄一段来自<a href="https://github.com/alexeyxo/protobuf-objc的文档" target="_blank" rel="external">https://github.com/alexeyxo/protobuf-objc的文档</a>)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">How To Install Protobuf</div><div class="line">Building the Objective-C Protobuf compiler</div><div class="line">Check if you have Homebrew</div><div class="line">brew -v</div><div class="line">If you don&apos;t already have Homebrew, then install it</div><div class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div><div class="line">Install the main Protobuf compiler and required tools</div><div class="line">brew install automake</div><div class="line">brew install libtool</div><div class="line">brew install protobuf</div><div class="line">(optional) Create a symlink to your Protobuf compiler.</div><div class="line">ln -s /usr/local/Cellar/protobuf/2.6.1/bin/protoc /usr/local/bin</div><div class="line">Clone this repository.</div><div class="line">git clone https://github.com/alexeyxo/protobuf-objc.git</div><div class="line">Build it!</div><div class="line">./build.sh</div></pre></td></tr></table></figure></p>
<p>什么？看不懂？没关系，本爷就是为了翻译才贴上的<br>首先，打开终端！</p>
<blockquote>
<p>brew -v</p>
</blockquote>
<p>：查看你的mac里面有没有装brew。brew是mac os里面，类似于ubuntu的apt-get的功能，都可以直接在终端输入命令然后安装程序。－v自然就是版本version的意思</p>
<blockquote>
<p>ruby -e “$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install" target="_blank" rel="external">https://raw.githubusercontent.com/Homebrew/install/master/install</a>)”</p>
</blockquote>
<p>这一句半懂不懂，，大概就是利用curl工具访问那个url，然后在ruby环境下载安装brew<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">brew install automake</div><div class="line">brew install libtool</div><div class="line">brew install protobuf</div></pre></td></tr></table></figure></p>
<p>就是利用brew下载安装了。protobuf就是我们想要的，另外两个是依赖库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/alexeyxo/protobuf-objc.git</div><div class="line">./build.sh</div></pre></td></tr></table></figure></p>
<p>从github下载protobuf－objc这个工程，build脚本里面做的是编译</p>
<p>注意：编译工程过程中，有可能会出现错误。别慌！看编译错误的提示。一般错误只是因为环境变量和路径没有配置好，少了一些东西，例如少了编译protobuf这个工程的依赖库，按照提示添加路径即可</p>
<p>有了工程以后，我们就可以开始测试一下怎么用protobuf了</p>
<p>打开Xcode！新建一个工程！<br>然后有两个方法把protobuf添加到你的工程里面，一个是直接添加，一个是利用cocoapod<br>强烈推荐后者，因为cocoapods能够很方便的管理第三方类库，以后人家的工程升级了，你只需要一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod update</div></pre></td></tr></table></figure></p>
<p>就ok～duang～</p>
<p>关于安装和使用cocoapod，属于另一个话题，看另一个博文<br>在Podfile添加下面这个句子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">platform :ios , 6.0</div><div class="line">pod &quot;ProtocolBuffers&quot;, &quot;~&gt; 1.9.7&quot;</div></pre></td></tr></table></figure></p>
<p>在保存之后，到终端，cd到工程里面，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod install</div></pre></td></tr></table></figure></p>
<p>等一会，cocoapod就会帮我们添加好，以后我们就应该打开<br>project的workspace，因为添加了pod作为子工程。</p>
<p>还没结束<br>在你的工程里面，新建一个文件夹，命名假如叫Protobuf<br>在这个文件夹里面新建一个proto文件。例如要在本地储存用户信息，那么就新建一个user.proto<br>里面内容可以如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">package csdnblog;</div><div class="line"></div><div class="line">message PBUser &#123;</div><div class="line"></div><div class="line">required string userId = 1;                       // 用户ID</div><div class="line">optional string nick = 2;                         // 用户昵称</div><div class="line">optional string avatar = 3;                       // 用户头像</div><div class="line"></div><div class="line">optional string password = 7;</div><div class="line">optional string email = 8;</div><div class="line">optional string mobile = 9;                       // 手机号码</div><div class="line">optional string qqOpenId = 10;                    // QQ ID</div><div class="line">optional string sinaId = 11;                      // SINA UserID</div><div class="line">optional string weixinId = 12;                    // WeChat UserID</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面这个例子包括了几个要素。<br>一个是包名。包的概念在object c里面没有，java里面有，c++里面namespace也是差不多意思。<br>顺便提一下，oc里面一般在库名前面添加两个字母，起的作用差不多就是包的作用，作为类的上一层组织结构。<br>例如官方的NS，例如AFNetworking这种第三方类库的AF。</p>
<p>回到正题。编写pb文件，第二个要素是message<br>一个message就是一个整体，里面有哪些必要的内容，哪些可选的内容。详细的proto语法随便一找一大把，就不啰嗦了。</p>
<p>写好了proto，接下来就是编译这个proto文件，protobuf－objc这个类库会编译声称一些源码，是读写proto数据的接口API。<br>编译命令如下：<br>先打开工程，建议单独新建一个文件夹作为输出路径，例如工程下新建文件夹Gen，用来放generate出来的.pb.h文件&amp;&amp;.pb.m文件<br>打开终端<br>cd到工程路径下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protoc --plugin=/usr/local/bin/protoc-gen-objc person.proto --objc_out=&quot;./Gen&quot;</div></pre></td></tr></table></figure></p>
<p>大功告成！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="孙小子" />
          <p class="site-author-name" itemprop="name">孙小子</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">28</span>
              <span class="site-state-item-name">Artikel</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">Kategorien</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">Tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">孙小子</span>
</div>

<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
